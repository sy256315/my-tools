<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand God Interaction</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; }
        canvas { display: block; transform: scaleX(-1); /* 镜像翻转，让操作更自然 */ }
        
        /* 摄像头画面 (调试用，设为透明隐身) */
        #video-feed {
            position: absolute; top: 0; left: 0; 
            width: 1px; height: 1px; opacity: 0; pointer-events: none;
        }

        .hud {
            position: absolute; top: 20px; width: 100%;
            text-align: center; pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px #00FFFF;
        }
        .hud h1 { color: #fff; font-size: 16px; margin: 0; letter-spacing: 2px; }
        .hud p { color: #0ff; font-size: 10px; margin-top: 5px; }
        
        /* 加载提示 */
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            color: #0ff; font-size: 14px; text-align: center;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0%{opacity:0.5;} 50%{opacity:1;} 100%{opacity:0.5;} }
    </style>
</head>
<body>

    <div id="loading">正在初始化 AI 视觉引擎...<br>(请允许摄像头权限)</div>
    
    <div class="hud">
        <h1>HAND GOD MODE</h1>
        <p>PINCH FINGERS TO CREATE ENERGY</p>
    </div>

    <video id="video-feed" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>

    <script>
        // --- 全局状态 ---
        let handPos = { x: 0, y: 0 }; // 手指位置 (归一化 0-1)
        let isPinching = false;       // 是否捏合
        let isHandDetected = false;

        // --- 1. AI 视觉初始化 (MediaPipe) ---
        const videoElement = document.getElementById('video-feed');
        const loadingElement = document.getElementById('loading');

        function onResults(results) {
            loadingElement.style.display = 'none'; // 隐藏加载中

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];
                
                // 获取食指指尖 (Index Tip - 8) 和 拇指指尖 (Thumb Tip - 4)
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                // 计算中心点作为“光标”
                handPos.x = (indexTip.x + thumbTip.x) / 2;
                handPos.y = (indexTip.y + thumbTip.y) / 2;

                // 计算两指距离 (判断捏合)
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) + 
                    Math.pow(indexTip.y - thumbTip.y, 2)
                );

                // 阈值判断 (距离小于 0.05 算捏合)
                isPinching = distance < 0.05;
            } else {
                isHandDetected = false;
                isPinching = false;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        const cameraAI = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraAI.start();


        // --- 2. 3D 粒子引擎 (Three.js) ---
        const CONFIG = {
            count: 8000,
            baseColor: new THREE.Color(0x00FFFF), // 青色
            activeColor: new THREE.Color(0xFF0055) // 红色
        };

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.001);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.z = 800;

        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 粒子系统
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        const velocities = [];
        
        for(let i=0; i<CONFIG.count; i++) {
            const r = 400 + Math.random() * 400;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            colors[i*3] = 0; colors[i*3+1] = 1; colors[i*3+2] = 1;
            velocities.push({x:0, y:0, z:0});
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const material = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. 融合逻辑 ---
        function animate() {
            requestAnimationFrame(animate);

            // 将 AI 坐标 (0-1) 映射到 3D 世界坐标 (-width/2 到 width/2)
            // 注意：MediaPipe 的 x 是反的（镜像），这里修正一下
            let targetX = (0.5 - handPos.x) * window.innerWidth * 1.5; 
            let targetY = -(handPos.y - 0.5) * window.innerHeight * 1.5;

            // 如果没检测到手，目标设为中心
            if (!isHandDetected) {
                targetX = 0; targetY = 0;
            }

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            
            // 颜色插值
            const targetColor = isPinching ? CONFIG.activeColor : CONFIG.baseColor;

            for(let i=0; i<CONFIG.count; i++) {
                const ix = i * 3;
                const v = velocities[i];

                const px = pos[ix];
                const py = pos[ix+1];
                const pz = pos[ix+2];

                // 计算引力中心
                const dx = targetX - px;
                const dy = targetY - py;
                const dz = 0 - pz; // Z 轴吸向 0 平面
                const distSq = dx*dx + dy*dy + dz*dz;

                // 物理力场
                if (isPinching && isHandDetected) {
                    // 捏合：强力黑洞
                    const force = 5000 / (distSq + 100);
                    v.x += dx * force * 0.1;
                    v.y += dy * force * 0.1;
                    v.z += dz * force * 0.1;
                    
                    // 随机震动
                    v.x += (Math.random()-0.5) * 5;
                    v.y += (Math.random()-0.5) * 5;
                    v.z += (Math.random()-0.5) * 5;
                } else if (isHandDetected) {
                    // 没捏合但有手：弱吸引，跟随
                    const force = 500 / (distSq + 500);
                    v.x += dx * force * 0.05;
                    v.y += dy * force * 0.05;
                    v.z += dz * force * 0.05;
                } else {
                    // 没手：缓慢漂浮
                    v.x += (Math.random()-0.5) * 0.1;
                    v.y += (Math.random()-0.5) * 0.1;
                    
                    // 缓慢回到原位(球形)
                    const r = Math.sqrt(px*px + py*py + pz*pz);
                    if (r > 600) { // 边界限制
                        v.x -= px * 0.0001;
                        v.y -= py * 0.0001;
                        v.z -= pz * 0.0001;
                    }
                }

                // 阻力
                v.x *= 0.95; v.y *= 0.95; v.z *= 0.95;

                // 更新位置
                pos[ix] += v.x;
                pos[ix+1] += v.y;
                pos[ix+2] += v.z;

                // 更新颜色
                const speed = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
                const t = Math.min(speed / 20, 1);
                
                col[ix] += (targetColor.r + t - col[ix]) * 0.1;
                col[ix+1] += (targetColor.g + t - col[ix+1]) * 0.1;
                col[ix+2] += (targetColor.b + t - col[ix+2]) * 0.1;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // 摄像机视差
            camera.lookAt(scene.position);
            renderer.render(scene, camera);
        }

        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>