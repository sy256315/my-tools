<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chaos Engine (Fixed)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas { display: block; }
        
        .ui-layer {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            mix-blend-mode: exclusion;
            transition: opacity 0.3s;
            z-index: 10;
        }
        .hint-main {
            font-size: 20px;
            font-weight: 900;
            color: #fff;
            letter-spacing: 8px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
            white-space: nowrap;
        }
        .hint-sub {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 2px;
            margin-top: 10px;
        }
        
        /* é”™è¯¯æç¤º */
        #status-msg {
            position: absolute; top: 10px; left: 0; width: 100%;
            text-align: center; color: yellow; font-size: 12px;
            pointer-events: none; z-index: 20;
        }

        body.active .ui-layer { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    </style>
</head>
<body>

    <div id="status-msg">æ­£åœ¨åŠ è½½å¼•æ“... (Loading Engine)</div>

    <div class="ui-layer">
        <div class="hint-main">CHAOS ENGINE</div>
        <div class="hint-sub">HOLD TO COLLAPSE â€¢ RELEASE TO DETONATE</div>
    </div>

    <script src="https://npm.elemecdn.com/three@0.128.0/build/three.min.js"></script>

    <script>
        // --- 0. åŠ è½½çŠ¶æ€æ£€æµ‹ ---
        window.onload = function() {
            const msg = document.getElementById('status-msg');
            if (typeof THREE === 'undefined') {
                msg.style.color = 'red';
                msg.innerHTML = "âŒ å¼•æ“åŠ è½½å¤±è´¥ (Blocked)<br>è¯·å°è¯•æ–­å¼€å…¬å¸VPNæˆ–ä½¿ç”¨æ‰‹æœºçƒ­ç‚¹";
            } else {
                msg.style.display = 'none'; // åŠ è½½æˆåŠŸï¼Œéšè—æç¤º
                init(); // å¯åŠ¨
            }
        };

        function init() {
            // --- ç‚¸è£‚é…ç½® ---
            const CONFIG = {
                count: 20000,        
                size: 3,             
                drag: 0.96,          
                gravity: 2.5,        
                explodePower: 80,    
                spinSpeed: 0.05,     
                colorLow: new THREE.Color(0xFFFFFF),  // ğŸ”´ ä¿®æ”¹ï¼šåˆå§‹è®¾ä¸ºç™½è‰²ï¼Œç¡®ä¿å¯è§
                colorHigh: new THREE.Color(0x00FFFF) 
            };

            // --- 1. åœºæ™¯ ---
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0005);

            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.z = 1000;

            const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // --- 2. ç²’å­ ---
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.count * 3);
            const colors = new Float32Array(CONFIG.count * 3);
            const velocities = []; 
            
            for (let i = 0; i < CONFIG.count; i++) {
                const r = Math.random() * 800 + 200; // ğŸ”´ ä¿®æ”¹ï¼šè®©ç²’å­åˆå§‹åˆ†å¸ƒé›†ä¸­ä¸€ç‚¹
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI * 2;

                positions[i*3] = r * Math.sin(theta) * Math.cos(phi);
                positions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
                positions[i*3+2] = r * Math.cos(theta);

                // åˆå§‹å…¨ç™½
                colors[i*3] = 1; colors[i*3+1] = 1; colors[i*3+2] = 1;

                velocities.push({ x: 0, y: 0, z: 0 });
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            function getSparkTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(0.2, 'rgba(255,255,255,0.5)');
                grad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(canvas);
            }

            const material = new THREE.PointsMaterial({
                size: CONFIG.size,
                map: getSparkTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 1,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const points = new THREE.Points(geometry, material);
            scene.add(points);

            // --- 3. äº¤äº’ ---
            const mouse = new THREE.Vector3(0, 0, 0);
            const raycaster = new THREE.Raycaster();
            const mouse2D = new THREE.Vector2(9999, 9999);
            let isHolding = false;
            let holdPower = 0;

            function updateMouse3D() {
                raycaster.setFromCamera(mouse2D, camera);
                const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                const target = new THREE.Vector3();
                raycaster.ray.intersectPlane(planeZ, target);
                if (target) { mouse.x = target.x; mouse.y = target.y; mouse.z = target.z; }
            }

            document.addEventListener('mousemove', e => {
                mouse2D.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse2D.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            document.addEventListener('touchmove', e => {
                if(e.touches.length > 0) {
                    e.preventDefault();
                    mouse2D.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                    mouse2D.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                }
            }, {passive: false});

            const startHold = () => { isHolding = true; document.body.classList.add('active'); };
            const endHold = () => { isHolding = false; document.body.classList.remove('active'); explode(); };

            document.addEventListener('mousedown', startHold);
            document.addEventListener('touchstart', startHold);
            document.addEventListener('mouseup', endHold);
            document.addEventListener('touchend', endHold);

            function explode() {
                shakeScreen(30); // éœ‡åŠ¨åé¦ˆ
                for(let i=0; i<CONFIG.count; i++) {
                    const ix = i*3;
                    const px = positions[ix];
                    const py = positions[ix+1];
                    const pz = positions[ix+2];
                    const dx = px - mouse.x;
                    const dy = py - mouse.y;
                    const dz = pz - mouse.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                    const force = (CONFIG.explodePower * (1 + holdPower * 6)) / Math.pow(dist, 0.5) * (Math.random() + 0.5);
                    velocities[i].x += (dx / dist) * force;
                    velocities[i].y += (dy / dist) * force;
                    velocities[i].z += (dz / dist) * force;
                }
                holdPower = 0;
            }

            let shakeIntensity = 0;
            function shakeScreen(amount) { shakeIntensity = amount; }

            // --- 4. å¾ªç¯ ---
            function animate() {
                requestAnimationFrame(animate);
                updateMouse3D();

                const p = positions;
                const c = colors;

                if (isHolding) {
                    holdPower = Math.min(holdPower + 0.02, 1.5);
                    shakeScreen(holdPower * 2);
                }

                // å®šä¹‰é¢œè‰² (åŠ¨æ€å˜åŒ–)
                const cLow = new THREE.Color(0x330000); // è¿åŠ¨åå˜å›æš—çº¢
                const cHigh = CONFIG.colorHigh;

                for (let i = 0; i < CONFIG.count; i++) {
                    const ix = i*3;
                    const vel = velocities[i];

                    const dx = mouse.x - p[ix];
                    const dy = mouse.y - p[ix+1];
                    const dz = mouse.z - p[ix+2];
                    const distSq = dx*dx + dy*dy + dz*dz;
                    const dist = Math.sqrt(distSq);

                    if (isHolding) {
                        const force = (CONFIG.gravity * 6 * (1+holdPower)) / (dist + 10);
                        vel.x += dx * force * 0.01;
                        vel.y += dy * force * 0.01;
                        vel.z += dz * force * 0.01;
                        vel.x += -dy * CONFIG.spinSpeed * 0.1;
                        vel.y += dx * CONFIG.spinSpeed * 0.1;
                    } else {
                        const force = (CONFIG.gravity * 0.5) / (dist + 100);
                        vel.x += dx * force * 0.005;
                        vel.y += dy * force * 0.005;
                        vel.z += dz * force * 0.005;
                    }

                    p[ix] += vel.x; p[ix+1] += vel.y; p[ix+2] += vel.z;
                    vel.x *= CONFIG.drag; vel.y *= CONFIG.drag; vel.z *= CONFIG.drag;

                    // é¢œè‰²è®¡ç®—
                    const speed = Math.sqrt(vel.x*vel.x + vel.y*vel.y + vel.z*vel.z);
                    const t = Math.min(speed / 20, 1);
                    
                    // åˆå§‹æ˜¯ç™½è‰²ï¼ŒåŠ¨èµ·æ¥åæ ¹æ®é€Ÿåº¦å˜è‰²
                    if (isHolding || speed > 0.5) {
                        c[ix]   = cLow.r + (cHigh.r - cLow.r) * t;
                        c[ix+1] = cLow.g + (cHigh.g - cLow.g) * t;
                        c[ix+2] = cLow.b + (cHigh.b - cLow.b) * t;
                        if(t>0.8) { c[ix]+=0.5; c[ix+1]+=0.5; c[ix+2]+=0.5; }
                    }
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;

                if (shakeIntensity > 0) {
                    camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                    camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                    shakeIntensity *= 0.9;
                    if (shakeIntensity < 0.5) { camera.position.x = 0; camera.position.y = 0; }
                } else {
                    camera.position.x += (mouse.x * 0.05 - camera.position.x) * 0.05;
                    camera.position.y += (mouse.y * 0.05 - camera.position.y) * 0.05;
                }
                camera.lookAt(scene.position);
                renderer.render(scene, camera);
            }
            animate();
        }

        window.addEventListener('resize', () => {
            location.reload(); // ç®€å•å¤„ç†ï¼šçª—å£å¤§å°æ”¹å˜æ—¶åˆ·æ–°ï¼Œé˜²æ­¢æ‹‰ä¼¸
        });
    </script>
</body>
</html>