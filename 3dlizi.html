<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Chaos Engine</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas { display: block; }
        
        .ui-layer {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            mix-blend-mode: exclusion;
            transition: opacity 0.3s;
            z-index: 10;
        }
        .hint-main {
            font-size: 20px;
            font-weight: 900;
            color: #fff;
            letter-spacing: 8px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
            white-space: nowrap;
        }
        .hint-sub {
            font-size: 10px;
            color: rgba(255,255,255,0.6);
            letter-spacing: 2px;
            margin-top: 10px;
        }
        
        body.active .ui-layer { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
    </style>
</head>
<body>

    <div class="ui-layer">
        <div class="hint-main">CHAOS ENGINE</div>
        <div class="hint-sub">HOLD TO COLLAPSE • RELEASE TO DETONATE</div>
    </div>

    <script src="https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 炸裂参数配置 ---
        const CONFIG = {
            count: 25000,        // 粒子数量：量大才爽
            size: 3,             // 粒子大小
            drag: 0.96,          // 空气阻力 (越小停得越快)
            gravity: 2.5,        // 黑洞引力强度
            explodePower: 80,    // 爆炸冲击力
            spinSpeed: 0.05,     // 漩涡旋转速度
            colorLow: new THREE.Color(0x330000),  // 低速颜色 (暗红)
            colorHigh: new THREE.Color(0x00FFFF)  // 高速颜色 (电光青)
        };

        // --- 1. 场景 ---
        const scene = new THREE.Scene();
        // 极淡的背景雾，增加深邃感
        scene.fog = new THREE.FogExp2(0x000000, 0.0005);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 1000;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 限制像素比以保证流畅
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. 粒子物理系统 ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const colors = new Float32Array(CONFIG.count * 3);
        
        // 物理属性存储
        const velocities = []; // 速度向量 {x, y, z}
        
        // 初始化：随机分布在屏幕中央
        for (let i = 0; i < CONFIG.count; i++) {
            const r = Math.random() * 2000; // 分布范围大一点
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI * 2;

            positions[i*3] = r * Math.sin(theta) * Math.cos(phi);
            positions[i*3+1] = r * Math.sin(theta) * Math.sin(phi);
            positions[i*3+2] = r * Math.cos(theta);

            // 初始颜色
            colors[i*3] = 0; colors[i*3+1] = 0; colors[i*3+2] = 0;

            velocities.push({ x: 0, y: 0, z: 0 });
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // 锋利的粒子纹理 (像火花)
        function getSparkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.2, 'rgba(255,255,255,0.5)');
            grad.addColorStop(0.5, 'rgba(255,255,255,0.1)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        const material = new THREE.PointsMaterial({
            size: CONFIG.size,
            map: getSparkTexture(),
            vertexColors: true,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending, // 叠加发光
            depthWrite: false
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);

        // --- 3. 交互逻辑 ---
        const mouse = new THREE.Vector3(0, 0, 0); // 鼠标在3D空间的位置
        const raycaster = new THREE.Raycaster();
        const mouse2D = new THREE.Vector2(9999, 9999); // 屏幕坐标
        let isHolding = false;
        let holdPower = 0; // 蓄力值

        // 将屏幕鼠标坐标转换为 3D 空间坐标 (Z=0 平面)
        function updateMouse3D() {
            raycaster.setFromCamera(mouse2D, camera);
            // 虚拟一个 Z=0 的平面来捕获鼠标位置
            const planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
            const target = new THREE.Vector3();
            raycaster.ray.intersectPlane(planeZ, target);
            if (target) {
                mouse.x = target.x;
                mouse.y = target.y;
                mouse.z = target.z; // 通常是0
            }
        }

        document.addEventListener('mousemove', e => {
            mouse2D.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse2D.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });
        document.addEventListener('touchmove', e => {
            if(e.touches.length > 0) {
                e.preventDefault();
                mouse2D.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse2D.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        }, {passive: false});

        const startHold = () => { isHolding = true; document.body.classList.add('active'); };
        const endHold = () => { isHolding = false; document.body.classList.remove('active'); explode(); };

        document.addEventListener('mousedown', startHold);
        document.addEventListener('touchstart', startHold);
        document.addEventListener('mouseup', endHold);
        document.addEventListener('touchend', endHold);

        // 爆炸函数：给所有粒子一个背离中心的巨大冲击力
        function explode() {
            // 震动屏幕
            shakeScreen(20);
            
            for(let i=0; i<CONFIG.count; i++) {
                const ix = i*3;
                const px = positions[ix];
                const py = positions[ix+1];
                const pz = positions[ix+2];

                // 计算到鼠标/中心的距离向量
                const dx = px - mouse.x;
                const dy = py - mouse.y;
                const dz = pz - mouse.z;
                
                // 归一化方向
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 0.1;
                
                // 爆炸力度：距离越近，受到的冲击越强 + 蓄力加成
                const force = (CONFIG.explodePower * (1 + holdPower * 5)) / Math.pow(dist, 0.5) * (Math.random() + 0.5);

                velocities[i].x += (dx / dist) * force;
                velocities[i].y += (dy / dist) * force;
                velocities[i].z += (dz / dist) * force;
            }
            holdPower = 0; // 重置蓄力
        }

        // 屏幕震动逻辑
        let shakeIntensity = 0;
        function shakeScreen(amount) {
            shakeIntensity = amount;
        }

        // --- 4. 物理引擎循环 ---
        function animate() {
            requestAnimationFrame(animate);

            updateMouse3D();

            const p = positions;
            const c = colors;

            // 蓄力逻辑
            if (isHolding) {
                holdPower = Math.min(holdPower + 0.02, 1.5); // 最大蓄力 1.5倍
                shakeScreen(holdPower * 2); // 蓄力时轻微震动
            }

            // 遍历所有粒子
            for (let i = 0; i < CONFIG.count; i++) {
                const ix = i*3;
                const vel = velocities[i];

                // --- 物理计算 ---
                
                // 1. 计算与引力中心(鼠标)的距离
                const dx = mouse.x - p[ix];
                const dy = mouse.y - p[ix+1];
                const dz = mouse.z - p[ix+2];
                const distSq = dx*dx + dy*dy + dz*dz;
                const dist = Math.sqrt(distSq);

                // 2. 施加力
                if (isHolding) {
                    // 黑洞模式：强引力 + 旋转力
                    const force = (CONFIG.gravity * 5 * (1+holdPower)) / (dist + 10);
                    vel.x += dx * force * 0.01;
                    vel.y += dy * force * 0.01;
                    vel.z += dz * force * 0.01;

                    // 漩涡旋转力 (绕Z轴)
                    vel.x += -dy * CONFIG.spinSpeed * 0.1;
                    vel.y += dx * CONFIG.spinSpeed * 0.1;
                } else {
                    // 自由模式：弱引力 (让粒子慢慢回聚，不至于飞丢)
                    const force = (CONFIG.gravity * 0.5) / (dist + 100);
                    vel.x += dx * force * 0.005;
                    vel.y += dy * force * 0.005;
                    vel.z += dz * force * 0.005;
                }

                // 3. 应用速度
                p[ix]   += vel.x;
                p[ix+1] += vel.y;
                p[ix+2] += vel.z;

                // 4. 阻力 (模拟空气摩擦)
                vel.x *= CONFIG.drag;
                vel.y *= CONFIG.drag;
                vel.z *= CONFIG.drag;

                // --- 视觉计算 (速度 -> 颜色) ---
                
                // 计算当前速度的大小
                const speed = Math.sqrt(vel.x*vel.x + vel.y*vel.y + vel.z*vel.z);
                const maxSpeed = 30; // 定义什么速度算“最亮”
                const t = Math.min(speed / maxSpeed, 1); // 0.0 - 1.0

                // 颜色插值：低速红 -> 高速青白
                c[ix]   = CONFIG.colorLow.r + (CONFIG.colorHigh.r - CONFIG.colorLow.r) * t;
                c[ix+1] = CONFIG.colorLow.g + (CONFIG.colorHigh.g - CONFIG.colorLow.g) * t;
                c[ix+2] = CONFIG.colorLow.b + (CONFIG.colorHigh.b - CONFIG.colorLow.b) * t;
                
                // 如果速度极快，加白
                if (t > 0.8) {
                    c[ix] += 0.5; c[ix+1] += 0.5; c[ix+2] += 0.5;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // 摄像机震动处理
            if (shakeIntensity > 0) {
                camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                camera.position.y += (Math.random() - 0.5) * shakeIntensity;
                shakeIntensity *= 0.9; // 震动衰减
                if (shakeIntensity < 0.5) {
                    camera.position.x = 0; camera.position.y = 0; // 复位
                }
            } else {
                // 平滑跟随鼠标视差
                camera.position.x += (mouse.x * 0.05 - camera.position.x) * 0.05;
                camera.position.y += (mouse.y * 0.05 - camera.position.y) * 0.05;
            }
            camera.lookAt(scene.position);

            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>